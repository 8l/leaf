对于每个package，编译出来的东西其实有两个作用
- 一个是


- an object file is a module that is ready for linking
- linking might happen at compile, but also might happen at loading time.
- an object file looks like this:

package table (ID'izing named imports)
    id   // sequential id
    path // absolute import path, unique in the system
type table
    // a table that will include all the tables
object table
    id   // 
    name // could be nameless, only named objects can be referenced
    typeId // the type signature
    content // an object might be a function (a series of byte code) or just a block of reserved memory
reference table (ID'izing named references)
    id          // sequential id
    packId      // package id
    name        // reference name, just for easier debugging
    objId       // object id, only useful for objects in this package, reference for 

package
    absolute path
    imports
    type table

importing is adding references into the reference table
- an object file here seems typeless
- however, importing a package will also import the types.
- but do not need to import the content though
- a type system is not that structured
- when we reference an object, we are referencing by its address, but we use it as an object
- an object in a package always has its fixed location on the heap

// we organize the table like this be 
type table
    id //
    face
    underlying
    size

    basics 
    func type, type, type, ret type
    struct {
        name type,
        name type,
    }
    pointer type,
    slice type // alias to pointers
    array type, length,
    interface {
        name type, // has to be function type
        name type,
    }
    named {
        pack // a pointer to packet
        name
        type
    }

- each type also has its underlying type
- all types in the type table are unique to each other
- so they'd better be sorted in some order

type =>
    - basics
    - func (type)* type
