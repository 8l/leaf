- 对于每个package，编译出来的东西要做两个事情
- 一个是说，它要提供编译其他子包的header那样的东西
    - 对于这个，里面要有所有symbol，所有type，每个type要能解析
- 另一个是说，它要提供链接的时候的所有东西
    - 对于这个，它要包含每个code segment，以及
- Type 这个东西，一个简单的做法是把所有的type都继承起来放进去
    - 另一种做法是只放这个包引入的新的
    - 只放这个包引入的新的似乎好一点
- 然后所有的package，在存的时候，对于每个package都有一个相对索引
    - 0永远是指自己，其他的排序按dependency，self是最后一个
- package里面有需要的新的type
    - 在import build的时候建type索引的时候不同的包引入的unamed type是可以合并的。
    - Named type是不能合并的
- type之前有数字的const，但是constant有的也有type，所以constant本身其实属于一个type
- 或者constant和type其实可以放一堆儿
- type有的是named，是没有resolve的，这个只在top decl中才会出现，top decl中需要先占一个符号的位置，只有named type需要占个位置。
    - 也就是说named type是可以向后指的（甚至永远是向后指的，因为总是先把位置占了）
- named type还会占一个symbol space
    - 其实可以所有symbol先都占一个位置
- 所以一个package里面一堆东西
    - 首先是一堆symbol，占一堆位置，symbol永远都是指向后面
    - 对于top symbols，我们总是这样的顺序
        - 首先占位置
            - type的实现指向后面
            - func的
        - 然后是const和type
        - 然后是func的type // func decl，实现指向后面
        - 然后是var的type // 一个一个来，不能乱顺序
        - 最后是func的
    - 其次是一坨const和type
    - 然后是var和func，func这个时候只是占
    - 其实构建的顺序没有那么重要，只要有了id和index，其他的都好说
    - 所以我们其实还是可以允许乱序的
    - constSym，指向一个typeObj，带一个值。
    - typeSym，指向一个typeObj
    - typeObj，本质是对内存意义的一种描述，所有type object存在一个index里，去重用。
    - funcSym，指向一个type，另外还指向一个code segment
    - varSym，指向一个type，另外还指向一个data segment
    - codeSeg，一堆ir
    - dataSeg，带一个size
    - 每个package有一个symbol map
    - 每个package有一个package index table，0永远指built-in，max-int永远指自己
    - 引用一个package的时候不需要载入code segment和data segment，但是需要载入type object
    - ir也有可能会引用其他package的type object，和symbol，但是不会引用其他package的code segment和data segment
        - 除非以后我们加进来跨包的优化
- 引用一个object，永远是一个package id加上一个object id
    - package id是当前这个object所在索引所对应的，是相对的
    - object id是绝对的
    - 所有东西都会存在一个地方
    - 所有type会建一个索引，这样对相同的type的引用是唯一的
    - 合并同类type，这是链接的时候需要做的事情，在对interface赋值的时候需要这个。
    - 也就是说，所有用到type id的地方，都会需要remap一下
